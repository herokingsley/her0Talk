#从一道概率面试题说开去

#### Her0kings1ey

扑克牌我们肯定都有玩过，但是我们有没有想过，在计算机的世界内，如何交一副扑克牌打乱呢？如果不引入随机生成的概念的话，那么每一次扑克牌的序列总是一样的，那么扑克牌游戏的结果也总是有迹可循。如果用于游戏中，则很容易被发现扑克牌序列中的规律，得出玩家的“最佳选择”。于是，我们需要一种方法，使得扑克牌的序列每次都经过随机生成。于是，就引出了下面这么一道面试题。

## 一道面试题


	设计一个合理的洗牌算法，使得洗牌之后，N张牌中，每张牌出现在任意位置的概率均为1/N。


### 一些可选的思路

#### 方案一 随机抽取

从N张牌中随机抽取一张牌，放在另一个序列中。放之前，首先检查一下序列中是否有重复的牌，如果重复的话，则重新进行抽取，直到第二个序列中有N张牌。

python代码实现如下:
	
	while(true):
		index = rand() % n
		if a[index] not in b:
			b.append(a[index])
		if len(b) == n:
			break

这个方案的缺点在于，判断是否已经有重复的牌以及相应产生的多余随机选择的操作耗时过久。计算时间复杂度可得，每次判断是否重复的成本为O(N)，于是整个方案的时间复杂度大概是O(N^2)。（这里还省去了对于重复抽取的时间耗时的计算，不过应该也是O(N^2)这个量级）。

#### 方案二 对方案一的改进

从N张牌中随机抽取一张牌，放在另一个序列中，从第一个序列中去掉这张牌，直到第一个序列没有牌。

python代码实现如下:

	num = n
	while(true):
		if num == 0:
			break
		index = rand() % n
		insertNum = a.pop(index)
		b.append(insertNum)
		num -= 1

咋一看这个方案似乎比方案一要好，但是如果从底层实现来想却不尽然。学过数据结构的我们知道，查询效率和插入删除效率是一对天然的矛盾体。当实现查询的效率高了，插入删除的效率就可能要下降了一个量级，反之亦然。如果这里的序列使用数组实现的话，那么做移除操作（将随机抽取的牌从序列中移除）的时候，复杂度则是O(N);如果序列使用链表实现的话，那么做查询操作（随机获取第一个序列的一张牌）的时候，复杂度则是O（N）。

也就是说，效率其实和方案一相近，只是少去了


### 两个进阶的方案

### 论证方案的正确性

### 代码与测试

## Reservoir sampling——蓄水池抽样算法

### 算法概述

### 应用场景说明