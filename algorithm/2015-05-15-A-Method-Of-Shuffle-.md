#从一道概率面试题说开去

#### Her0kings1ey

扑克牌我们肯定都有玩过，但是我们有没有想过，在计算机的世界内，如何交一副扑克牌打乱呢？如果不引入随机生成的概念的话，那么每一次扑克牌的序列总是一样的，那么扑克牌游戏的结果也总是有迹可循。如果用于游戏中，则很容易被发现扑克牌序列中的规律，得出玩家的“最佳选择”。于是，我们需要一种方法，使得扑克牌的序列每次都经过随机生成。于是，就引出了下面这么一道面试题。

## 一道面试题


	设计一个合理的洗牌算法，使得洗牌之后，N张牌中，每张牌出现在任意位置的概率均为1/N。


### 一些可选的思路

#### 方案一 随机抽取

从N张牌中随机抽取一张牌，放在另一个序列中。放之前，首先检查一下序列中是否有重复的牌，如果重复的话，则重新进行抽取，直到第二个序列中有N张牌。

python代码实现如下:
	
	while(true):
		index = rand() % n
		if a[index] not in b:
			b.append(a[index])
		if len(b) == n:
			break

这个方案的缺点在于，判断是否已经有重复的牌以及相应产生的多余随机选择的操作耗时过久。计算时间复杂度可得，每次判断是否重复的成本为O(N)，于是整个方案的时间复杂度大概是O(N^2)。（这里还省去了对于重复抽取的时间耗时的计算，不过应该也是O(N^2)这个量级）。

#### 方案二 对方案一的改进

从N张牌中随机抽取一张牌，放在另一个序列中，从第一个序列中去掉这张牌，直到第一个序列没有牌。

python代码实现如下:

	num = n
	while(true):
		if num == 0:
			break
		index = rand() % n
		insertNum = a.pop(index)
		b.append(insertNum)
		num -= 1

咋一看这个方案似乎比方案一要好，但是如果从底层实现来想却不尽然。学过数据结构的我们知道，查询效率和插入删除效率是一对天然的矛盾体。当实现查询的效率高了，插入删除的效率就可能要下降了一个量级，反之亦然。如果这里的序列使用数组实现的话，那么做移除操作（将随机抽取的牌从序列中移除）的时候，复杂度则是O(N);如果序列使用链表实现的话，那么做查询操作（随机获取第一个序列的一张牌）的时候，复杂度则是O（N）。

也就是说，方案二和方案一相比，只是少去了判断是否重复的操作，效率略优。

### 两个进阶的方案

#### 进阶方案一

在一些游戏中，还采用了切换(swap)的方式实现洗牌的逻辑，即在重复进行多次如下的操作：随意选择1-N的两张牌，将其进行切换。

python代码实现如下:

	NUM_OF_SWAP = 10000
	for i in range(NUM_OF_SWAP):
		a_index = rand() % n
		b_index = rand() % n
		swap(a[a_index],b[b_index])

当然，这种洗牌不能做到问题定义的随机，因为某张牌在每个位置出现的概率并不均为1/N。


#### 进阶方案二

进行N次迭代，在第i次迭代中，在N张牌中随机选出一张牌与第i张牌进行交换。

python代码实现如下:

	for i in range(n):
		index = rand() % n
		swap(a[i], a[index])

#### 进阶方案三

方案三与方案二相仿，只是在第i次迭代中，在前i张牌中随机选出一张牌与第i张牌进行交换。

python代码实现如下:
	
	for i in range(n):
		index = rand() % i
		swap(a[i], a[index])

同样，我们在下文中论证其是否正确。

### 论证方案的正确性

上一节我们提出了三种进阶方案，我们将在本节讨论后两种的正确性。

我们采用数学归纳法来验证两种算法。（提到数学归纳法是不是有种梦回中学年代的感觉--|）

首先当n=1的时候，显然两种算法都成立。

于是我们假设n=k的时候，两种算法成立。

当n=k+1时，我们先来看第一种算法。

对第k+1张牌来说，由于是随机生成一个1到k+1之间的数来决定它的位置，显然符合1/(k+1)的概率。但对于第x张牌来说(1<= x <= k)，它之前出现在位置p(1<= p <= k)的概率为1/k，则它 


### 代码与测试

## Reservoir sampling——蓄水池抽样算法

### 算法概述

### 应用场景说明

### 参考资料

