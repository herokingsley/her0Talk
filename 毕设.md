## 毕设提纲

目录

一、	前言

(为什么要以这个毕业设计为题。)
在当今的互联网浪潮下，各种应用软件层出不穷，而形形色色的应用软件，都加入了网络交互的内容。在这个讲究“云计算”、“云存储”的时代，我们的信息存储在网上，我们的一次与软件的交互，往往通过网络，从世界的各个部分返回信息。

随着信息科学与技术的不断发展，我们逐渐迈入了互联网时代，在这过程中，有前人提出了一些概念和问题，其中一个就是C10K问题。C10K问题指的是，当前的web服务器（注：此处的web服务器指的是一个运行在服务器上的进程）需要同时处理一万个以上的客户端了。

（相关领域综述）

（基础概念的陈述）

TCP/IP的简介

套接字简介

为此，计算机科学技术领域的科学家和工程师们做了不懈的努力。从操作系统层面上，设计了五大I/O模型，并设计出了非阻塞的系统调用和诸如poll和epoll这样同时监听多个文件描述符读写事件的机制；从工程应用领域上，设计了诸如Acceptor-Connector、事件驱动Reactor的模型，一方面增加了软件设计人员的开发效率，另一方面把代码模块有效地解耦，将可重用的代码逻辑抽取出来封装为独立的模块。

在开源社区中，有很多具有开源精神的工程师，凭着个人或是团队的能力和经验，将上述模型和机制应用在了实际的工程中，开发出了不少可重用的类库、编程框架。

* libevent，一个用c语言编写的跨平台的事件推送API库，它提供以下功能：当超时事件或是某个文件描述符指定的事件发生时，执行用户指定的回调函数。另外，它也提供定时任务或是信号(操作系统层面的信号机制)发生时执行回调函数。
* muduo，一个用c++开发的linux下高效非阻塞事件驱动的网络API库。
* libev，比libevent，轻量级的一个网络API库。
* ACE framework，由提出Reactor模型的作者组织开发的一个C++面向对象的网络API库，实现了多种并发通信的核心模型。
 

在几家公司实习后，发现服务端开发工程师在编码方面，不仅需要处理网络编程处理世界各地的数据连接，还需要将业务逻辑实现，将业务数据返回，这样往往会使业务代码和网络编程的代码相互混合，使得工程上各个组件间的耦合性较大。因此，很多企业在内部都有自己的一套网络编程库，提高工程效率。

本篇毕业论文就是站在这个角度上，希望通过自己的努力，开发一个基于Reactor模型的网络API库，将网络编程的开发模块化，减轻重复的网络通信的代码的编写，让工程师的重心回归到业务上，将业务代码和网络库代码隔离，使得项目更符合软件工程的规范。

本论文将分为以下几个部分。
1. 设计目标，阐述了当前一般服务器进程的需求，以及网络API库的功能。
2. 设计思路，阐述了设计网络API库的思路，比较了多重I/O模型的优劣。
3. 设计方案，阐述了网络API库的架构与模型层次，如何编写该网络API库。
4. 实现细节，针对一些核心的模块进行讲解及展示。
5. 测试方案，阐述如何验证该网络API库的功能与效率。
6. 结论，展示最终的网络API库以及基于该网络API库编写的网络应用。

二、设计目标

（1）现实世界的需求

随着互联网时代的到来，越来越多的软件都开始与服务器后台进行交互，从而提供用户更多的功能与更好的体验。网络游戏、在线服务平台、在线聊天室等软件，除了需要界面前端的软件设计外，还设计到了服务器端后台的网络编程，如何将重复的网络通信代码剥离，封装为独立的模块，不同的软件应用只要基于自己提供的业务功能编写相应的逻辑处理代码，就是本篇毕业论文所想要达到的目标。

下面首先来分析发现网络应用软件设计到的逻辑代码对应到哪些网络事件。

一般来说你，网络应用软件关注的事件有：

1. TCP连接建立
2. 读写事件（包括TCP/UDP）
3. 超时事件（定时事件）
4. TCP连接关闭（包括主动关闭和被动关闭）

（2）毕设的主要功能

由此，我们可以分析出本个毕业设计主要设计的功能内容，即由业务开发人员编写上述事件的代码，并启动服务，由该服务在连接建立、读写事件等事件发生的时候主动回调业务开发人员编写的代码。

用例图如下：

编写业务逻辑代码->初始化框架程序->绑定业务逻辑代码到相应监听器上->启动框架程序

运行时序图：

框架程序监听网络事件以及超时事件->事件发生->框架程序主动回调业务开发人员注册好的业务逻辑函数->处理

（3）在本篇论文的最后，还将编写几个基础的网络应用服务展示毕设的功能。

三、设计思路

（1）毕设难点、要点的分析

由于本个毕业设计的主要目标是对网络应用中的网络通信部分进行解耦和封装，将其涉及到的逻辑封装到一个独立的模块中，所以，网络编程的难点也是本个毕业设计的主要难点。

（网络编程的难点）



另外，将逻辑剥离到独立的模块，如何做到底层通信代码对业务开发者透明，同时对框架的应用易学易用，也是挑战之一。


（2）毕设设计的思路

网络编程，涉及到了大量的I/O读写。因为，我们先确定框架使用的I/O模型。

（5种I/O模型的比较）

（Reactor与PReactor的比较）

确定了I/O模型后，我们结合前人的研究结果，采用Reactor模型作为我们的核心结构。框架依赖事件驱动来运作，也就是说，通过检测网络事件的发生，由框架程序主动回调用户注册的回调函数来处理业务逻辑。

（Reactor的事件模型图）

（3）毕设的架构图

最终，综合上述考虑，我们的毕设选用了此种架构。可以看出，我们的毕设处于应用层以上，系统库以上的层级。它能够基于系统库函数调用正常运作（即本身不依赖第三方库），也能通过其他第三方库扩展功能。

四、设计方案

于是，基于上述的思路，继续阐述毕设的设计方案。核心的代码将是以下三个类，HReactor、Channel、Poller。他们的关系基本如下：

（三者图）

HReactor内包含了该框架的主要运行逻辑，事件在HReactor发现并递交给相应的Channel完成处理。

同时后续通过扩展Poller来完成不同的网络事件发现机制。

基于HReactor结构，扩展出去，我们实现了TcpServer和Udp Server。



五、实现细节

（列举部分核心代码）

（HReactor run方法的代码） 

TcpServer和UdpServer对应了最终应用的Tcp服务器进程和Udp服务器进程。

Socket提供了对Socket操作的面向对象封装。

Channel则是对Socket和事件回调函数的封装。




六、测试方案

（1）采用Ping-Pong协议来进行效率测试。

 (2) 采用disCharge协议来进行连接数量测试。

七、结论



一些基础知识的归纳 

IO的5种模型

1、阻塞式IO，调用read等函数会阻塞在系统调用中，直到有数据返回才会返回到应用程序中。缺点：应用程序会被单个连接阻塞而无法处理其他连接
2、非阻塞式IO，调用read等函数如果没数据返回会返回一个linux下的一个错误，也被称为轮训式IO，缺点：对CPU的利用率较低。
3、IO多路复用，利用poll/epoll/select/kqueue这几个模型监听多个fd，将阻塞在多路复用上，当指定数目的事件到达或是阻塞超时的时候返回。
4、信号驱动式IO，当有数据到达时系统发送信号给应用程序并让应用程序将数据从内核缓冲区拷贝到应用缓冲区。
5、异步IO，当有数据到达时系统将内核缓冲区的数据拷贝到应用缓冲区才返回，如：windows下的IOCP。

TCP网络编程事件的简单抽象。
1、连接的建立。(客户端connect与服务端accept对）
2、连接的断开，包括主动断开（close、shutdown）和被动断开(read返回0，即对端发送RST）
3、消息到达，文件描述符可读（业务逻辑关注的核心，客户端和服务端信息的交互）
4、消息发送完毕，即阻塞式write返回，本质上是数据已经写入了操作系统内核的缓冲区。

并发网络库

首先，我们来确定网络库的编程模型。对于网络编程来说，常用的模型发展大致如下。最直截了当的模型就是我们在计算机网络编程中学习的阻塞式IO的编写，这个模型的缺点显而易见。虽然极其容易编写，但是我们的应用程序只能够同时处理单个单向的数据传输，效率实在太低。于是，又延伸出两种模型，服务端接收到一个新的客户端连接后(accept返回后），采用新开进程或是新开线程的方式处理这个客户端连接。这两种方式都存在着当并发连接数不断增多时，对系统的资源消耗过大，资源利用率较低的缺点，而且每次新建进程或是线程都需要额外开销，在此基础上有人又提出了在应用程序初始化的时候预先新建出进程（对同样的资源进行复制）或线程，但是依然存在着系统资源有限的困局。于是，凭借着系统级的IO多路复用的提出，Reactor模型也应运而生。

Reactor模型的本质在于事件驱动。它和我们上面提出的各种模型有着一个很大的差别。上述的各种模型都是主动去调用网络的IO函数(read、write)等，而Reactor则恰恰相反，使用IO多路复用后(在Linux平台我们使用epoll），我们把需要监听的网络IO事件及其相关的文件描述符加入epoll的队列中，并将相应事件的处理函数绑定在事件循环对象相应的槽里。这样，当有网络事件的时候，Reactor模型的事件循环对象会主动地回调我们之前注册的函数。

这个模型对于网络库的编写是有着十分的优势的。从上面的描述我们可以看到，在Reactor中，网络通信的代码和业务处理的代码（即我们注册的处理函数）是分开的，有助于我们将网络通信IO的部分提取为公用的框架或者库，使用者只需要编写关键的业务逻辑代码，并通过注册回调或是复写虚函数的方式，就可以实现完整的网络服务。另外使用IO多路复用有助于提高并发连接数，在现代的网络编程中，单机同时处理十万并发已经不成问题。

因此，我决定以Reactor为设计并发网络库的模型，并提出两个具体的实施方案，(1)单线程的Reactor，Reactor触发网络事件后，串行处理网络事件。（2）单个reactor配上多个工作线程来处理业务回调函数。

两个方案的一些对比：（1）方案无论是网络库的代码还是使用库的应用程序的代码相对都比较简单，但是处理的业务不能够是太过耗时的任务，否则会影响其他事件。（2）方案则需要处理多线程中同步、竞争等问题，代码相对更为复杂，但是能够实现更多样化的网络服务，对使用库的工程师要求也更高。

最终我们以（1）方案为基础进行这次设计。（时间足够则进行（2）方案的扩展）。

三、设计内容

框架业务逻辑图：
（当连接到达网络库发生的事情。）

类图：（网络库结构）

各部件的详解：

Reactor设计模式。

EventLoop

IO多路复用。

性能测试的方法


四、结论

实现的网络库的效率测试，并提供以此网络库为基础扩展出来的应用(简单的比如echo、time、day、discard服务器等)



五、参考文献

六、附录（代码文件）

（github地址）